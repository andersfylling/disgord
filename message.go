package disgord

import (
	"context"
	"errors"
	"fmt"
	"net/http"

	"github.com/andersfylling/disgord/internal/endpoint"
	"github.com/andersfylling/disgord/internal/httd"
)

// different message acticity types
const (
	_ = iota
	MessageActivityTypeJoin
	MessageActivityTypeSpectate
	MessageActivityTypeListen
	MessageActivityTypeJoinRequest
)

type MessageFlag uint

const (
	// MessageFlagCrossposted this message has been published to subscribed Channels (via Channel Following)
	MessageFlagCrossposted MessageFlag = 1 << iota

	// MessageFlagIsCrosspost this message originated from a message in another channel (via Channel Following)
	MessageFlagIsCrosspost

	// MessageFlagSupressEmbeds do not include any embeds when serializing this message
	MessageFlagSupressEmbeds
)

// The different message types usually generated by Discord. eg. "a new user joined"
type MessageType uint // TODO: once auto generated, un-export this.

const (
	MessageTypeDefault MessageType = iota
	MessageTypeRecipientAdd
	MessageTypeRecipientRemove
	MessageTypeCall
	MessageTypeChannelNameChange
	MessageTypeChannelIconChange
	MessageTypeChannelPinnedMessage
	MessageTypeGuildMemberJoin
	MessageTypeUserPremiumGuildSubscription
	MessageTypeUserPremiumGuildSubscriptionTier1
	MessageTypeUserPremiumGuildSubscriptionTier2
	MessageTypeUserPremiumGuildSubscriptionTier3
	MessageTypeChannelFollowAdd
)

const (
	AttachmentSpoilerPrefix = "SPOILER_"
)

// NewMessage ...
func NewMessage() *Message {
	return &Message{}
}

//func NewDeletedMessage() *DeletedMessage {
//	return &DeletedMessage{}
//}

//type DeletedMessage struct {
//	ID        Snowflake `json:"id"`
//	ChannelID Snowflake `json:"channel_id"`
//}

// MessageActivity https://discord.com/developers/docs/resources/channel#message-object-message-activity-structure
type MessageActivity struct {
	Type    int    `json:"type"`
	PartyID string `json:"party_id"`
}

type MentionChannel struct {
	ID      Snowflake `json:"id"`
	GuildID Snowflake `json:"guild_id"`
	Type    int       `json:"type"`
	Name    string    `json:"name"`
}

type MessageReference struct {
	MessageID Snowflake `json:"message_id"`
	ChannelID Snowflake `json:"channel_id"`
	GuildID   Snowflake `json:"guild_id"`
}

// MessageApplication https://discord.com/developers/docs/resources/channel#message-object-message-application-structure
type MessageApplication struct {
	ID          Snowflake `json:"id"`
	CoverImage  string    `json:"cover_image"`
	Description string    `json:"description"`
	Icon        string    `json:"icon"`
	Name        string    `json:"name"`
}

// Message https://discord.com/developers/docs/resources/channel#message-object-message-structure
type Message struct {
	ID               Snowflake          `json:"id"`
	ChannelID        Snowflake          `json:"channel_id"`
	Author           *User              `json:"author"`
	Member           *Member            `json:"member"`
	Content          string             `json:"content"`
	Timestamp        Time               `json:"timestamp"`
	EditedTimestamp  Time               `json:"edited_timestamp"` // ?
	Tts              bool               `json:"tts"`
	MentionEveryone  bool               `json:"mention_everyone"`
	Mentions         []*User            `json:"mentions"`
	MentionRoles     []Snowflake        `json:"mention_roles"`
	MentionChannels  []*MentionChannel  `json:"mention_channels"`
	Attachments      []*Attachment      `json:"attachments"`
	Embeds           []*Embed           `json:"embeds"`
	Reactions        []*Reaction        `json:"reactions"` // ?
	Nonce            interface{}        `json:"nonce"`     // NOT A SNOWFLAKE! DONT TOUCH!
	Pinned           bool               `json:"pinned"`
	WebhookID        Snowflake          `json:"webhook_id"` // ?
	Type             MessageType        `json:"type"`
	Activity         MessageActivity    `json:"activity"`
	Application      MessageApplication `json:"application"`
	MessageReference *MessageReference  `json:"message_reference"`
	Flags            MessageFlag        `json:"flags"`

	// GuildID is not set when using a REST request. Only socket events.
	GuildID Snowflake `json:"guild_id"`

	// SpoilerTagContent is only true if the entire message text is tagged as a spoiler (aka completely wrapped in ||)
	SpoilerTagContent        bool `json:"-"`
	SpoilerTagAllAttachments bool `json:"-"`
	HasSpoilerImage          bool `json:"-"`
}

var _ Reseter = (*Message)(nil)
var _ fmt.Stringer = (*Message)(nil)
var _ internalUpdater = (*Message)(nil)
var _ Copier = (*Message)(nil)
var _ DeepCopier = (*Message)(nil)

func (m *Message) String() string {
	return "message{" + m.ID.String() + "}"
}

// DiscordURL returns the Discord link to the message. This can be used to jump
// directly to a message from within the client.
//
// Example: https://discord.com/channels/319567980491046913/644376487331495967/646925626523254795
func (m *Message) DiscordURL() (string, error) {
	if m.ID.IsZero() {
		return "", errors.New("missing message ID")
	}
	if m.GuildID.IsZero() {
		return "", errors.New("missing guild ID")
	}
	if m.ChannelID.IsZero() {
		return "", errors.New("missing channel ID")
	}

	return fmt.Sprintf(
		"https://discord.com/channels/%d/%d/%d",
		m.GuildID, m.ChannelID, m.ID,
	), nil
}

func (m *Message) updateInternals() {
	if len(m.Content) >= len("||||") {
		prefix := m.Content[0:2]
		suffix := m.Content[len(m.Content)-2 : len(m.Content)]
		m.SpoilerTagContent = prefix+suffix == "||||"
	}

	m.SpoilerTagAllAttachments = len(m.Attachments) > 0
	for i := range m.Attachments {
		m.Attachments[i].updateInternals()
		if !m.Attachments[i].SpoilerTag {
			m.SpoilerTagAllAttachments = false
			break
		} else {
			m.HasSpoilerImage = true
		}
	}

	if m.Author != nil && m.Member != nil {
		m.Member.UserID = m.Author.ID
	}
}

// IsDirectMessage checks if the message is from a direct message channel.
//
// WARNING! Note that, when fetching messages using the REST API the
// guildID might be empty -> giving a false positive.
func (m *Message) IsDirectMessage() bool {
	return m.Type == MessageTypeDefault && m.GuildID.IsZero()
}

// DeepCopy see interface at struct.go#DeepCopier
func (m *Message) DeepCopy() (copy interface{}) {
	copy = NewMessage()
	m.CopyOverTo(copy)

	return
}

// CopyOverTo see interface at struct.go#Copier
func (m *Message) CopyOverTo(other interface{}) (err error) {
	var message *Message
	var valid bool
	if message, valid = other.(*Message); !valid {
		err = newErrorUnsupportedType("argument given is not a *Message type")
		return
	}

	message.ID = m.ID
	message.ChannelID = m.ChannelID
	message.Content = m.Content
	message.Timestamp = m.Timestamp
	message.EditedTimestamp = m.EditedTimestamp
	message.Tts = m.Tts
	message.MentionEveryone = m.MentionEveryone
	message.MentionRoles = m.MentionRoles
	message.Pinned = m.Pinned
	message.WebhookID = m.WebhookID
	message.Type = m.Type
	message.Activity = m.Activity
	message.Application = m.Application
	message.GuildID = m.GuildID
	message.HasSpoilerImage = m.HasSpoilerImage
	message.Nonce = m.Nonce
	message.SpoilerTagAllAttachments = m.SpoilerTagAllAttachments
	message.SpoilerTagContent = m.SpoilerTagContent
	message.Nonce = m.Nonce

	if m.Author != nil {
		message.Author = m.Author.DeepCopy().(*User)
	}

	for _, mention := range m.Mentions {
		message.Mentions = append(message.Mentions, mention.DeepCopy().(*User))
	}

	for _, attachment := range m.Attachments {
		message.Attachments = append(message.Attachments, attachment.DeepCopy().(*Attachment))
	}

	for _, embed := range m.Embeds {
		message.Embeds = append(message.Embeds, embed.DeepCopy().(*Embed))
	}

	for _, reaction := range m.Reactions {
		message.Reactions = append(message.Reactions, reaction.DeepCopy().(*Reaction))
	}

	return
}

// MessageSender is an interface which only holds the method needed for creating a channel message
type MessageSender interface {
	CreateMessage(ctx context.Context, channelID Snowflake, params *CreateMessageParams, flags ...Flag) (ret *Message, err error)
}

// Send sends this message to discord.
func (m *Message) Send(ctx context.Context, client MessageSender, flags ...Flag) (msg *Message, err error) {
	nonce := fmt.Sprint(m.Nonce)
	if len(nonce) > 25 {
		return nil, errors.New("nonce can not be more than 25 characters")
	}

	// TODO: attachments
	params := &CreateMessageParams{
		Content: m.Content,
		Tts:     m.Tts,
		Nonce:   nonce,
		// File: ...
		// Embed: ...
	}
	if len(m.Embeds) > 0 {
		params.Embed = &Embed{}
		_ = m.Embeds[0].CopyOverTo(params.Embed)
	}
	channelID := m.ChannelID

	msg, err = client.CreateMessage(ctx, channelID, params, flags...)
	return
}

type msgSender interface {
	SendMsg(ctx context.Context, channelID Snowflake, data ...interface{}) (msg *Message, err error)
}

// Reply input any type as an reply. int, string, an object, etc.
func (m *Message) Reply(ctx context.Context, client msgSender, data ...interface{}) (*Message, error) {
	return client.SendMsg(ctx, m.ChannelID, data...)
}

func (m *Message) React(ctx context.Context, s Session, emoji interface{}, flags ...Flag) error {
	if m.ID.IsZero() {
		return errors.New("missing message ID")
	} else if m.ChannelID.IsZero() {
		return errors.New("missing channel ID")
	}

	return s.Channel(m.ChannelID).Message(m.ID).Reaction(emoji).WithContext(ctx).Create(flags...)
}

func (m *Message) Unreact(ctx context.Context, s Session, emoji interface{}, flags ...Flag) error {
	if m.ID.IsZero() {
		return errors.New("missing message ID")
	} else if m.ChannelID.IsZero() {
		return errors.New("missing channel ID")
	}

	return s.Channel(m.ChannelID).Message(m.ID).Reaction(emoji).WithContext(ctx).DeleteOwn(flags...)
}

// AddReaction adds a reaction to the message
//func (m *Message) AddReaction(reaction *Reaction) {}

// RemoveReaction removes a reaction from the message
//func (m *Message) RemoveReaction(id Snowflake)    {}

//////////////////////////////////////////////////////
//
// REST Methods
//
//////////////////////////////////////////////////////

type MessageQueryBuilder interface {
	WithContext(ctx context.Context) MessageQueryBuilder

	// PinMessageID Pin a message by its ID and channel ID. Requires the 'MANAGE_MESSAGES' permission.
	// Returns a 204 empty response on success.
	Pin(ctx context.Context, flags ...Flag) error

	// UnpinMessageID Delete a pinned message in a channel. Requires the 'MANAGE_MESSAGES' permission.
	// Returns a 204 empty response on success. Returns a 204 empty response on success.
	Unpin(ctx context.Context, flags ...Flag) error

	// GetMessage Returns a specific message in the channel. If operating on a guild channel, this endpoints
	// requires the 'READ_MESSAGE_HISTORY' permission to be present on the current user.
	// Returns a message object on success.
	Get(ctx context.Context, flags ...Flag) (*Message, error)

	// UpdateMessage Edit a previously sent message. You can only edit messages that have been sent by the
	// current user. Returns a message object. Fires a Message Update Gateway event.
	Update(ctx context.Context, flags ...Flag) *updateMessageBuilder
	SetContent(ctx context.Context, content string) (*Message, error)
	SetEmbed(ctx context.Context, embed *Embed) (*Message, error)

	// DeleteMessage Delete a message. If operating on a guild channel and trying to delete a message that was not
	// sent by the current user, this endpoint requires the 'MANAGE_MESSAGES' permission. Returns a 204 empty response
	// on success. Fires a Message Delete Gateway event.
	Delete(ctx context.Context, flags ...Flag) error

	// DeleteAllReactions Deletes all reactions on a message. This endpoint requires the 'MANAGE_MESSAGES'
	// permission to be present on the current user.
	DeleteAllReactions(flags ...Flag) error

	Reaction(emoji interface{}) ReactionQueryBuilder
}

func (c channelQueryBuilder) Message(id Snowflake) MessageQueryBuilder {
	return &messageQueryBuilder{client: c.client, cid: c.cid, mid: id}
}

type messageQueryBuilder struct {
	ctx    context.Context
	client *Client
	cid    Snowflake
	mid    Snowflake
}

func (m messageQueryBuilder) WithContext(ctx context.Context) MessageQueryBuilder {
	m.ctx = ctx
	return &m
}

// Get Returns a specific message in the channel. If operating on a guild channel, this endpoints
// requires the 'READ_MESSAGE_HISTORY' permission to be present on the current user.
// Returns a message object on success.
//  Method                  GET
//  Endpoint                /channels/{channel.id}/messages/{message.id}
//  Discord documentation   https://discord.com/developers/docs/resources/channel#get-channel-message
//  Reviewed                2018-06-10
//  Comment                 -
func (m messageQueryBuilder) Get(ctx context.Context, flags ...Flag) (message *Message, err error) {
	if m.cid.IsZero() {
		err = errors.New("channelID must be set to get channel messages")
		return
	}
	if m.mid.IsZero() {
		err = errors.New("messageID must be set to get a specific message from a channel")
		return
	}

	msg, _ := m.client.cache.GetMessage(m.cid, m.mid)
	if msg != nil {
		return msg, nil
	}

	r := m.client.newRESTRequest(&httd.Request{
		Endpoint: endpoint.ChannelMessage(m.cid, m.mid),
		Ctx:      ctx,
	}, flags)
	r.pool = m.client.pool.message
	r.factory = func() interface{} {
		return &Message{}
	}

	return getMessage(r.Execute)
}

// Update Edit a previously sent message. You can only edit messages that have been sent by the
// current user. Returns a message object. Fires a Message Update Gateway event.
//  Method                  PATCH
//  Endpoint                /channels/{channel.id}/messages/{message.id}
//  Discord documentation   https://discord.com/developers/docs/resources/channel#edit-message
//  Reviewed                2018-06-10
//  Comment                 All parameters to this endpoint are optional.
// TODO: verify embed is working
func (m messageQueryBuilder) Update(ctx context.Context, flags ...Flag) (builder *updateMessageBuilder) {
	builder = &updateMessageBuilder{}
	builder.r.itemFactory = func() interface{} {
		return &Message{}
	}
	builder.r.flags = flags
	builder.r.addPrereq(m.cid.IsZero(), "channelID must be set to get channel messages")
	builder.r.addPrereq(m.mid.IsZero(), "msgID must be set to edit the message")
	builder.r.setup(m.client.req, &httd.Request{
		Method:      httd.MethodPatch,
		Ctx:         ctx,
		Endpoint:    "/channels/" + m.cid.String() + "/messages/" + m.mid.String(),
		ContentType: httd.ContentTypeJSON,
	}, nil)

	return builder
}

// Delete If operating on a guild channel and trying to delete a message that was not
// sent by the current user, this endpoint requires the 'MANAGE_MESSAGES' permission. Returns a 204 empty response
// on success. Fires a Message Delete Gateway event.
//  Method                  DELETE
//  Endpoint                /channels/{channel.id}/messages/{message.id}
//  Discord documentation   https://discord.com/developers/docs/resources/channel#delete-message
//  Reviewed                2018-06-10
//  Comment                 -
func (m messageQueryBuilder) Delete(ctx context.Context, flags ...Flag) (err error) {
	if m.cid.IsZero() {
		err = errors.New("channelID must be set to get channel messages")
		return
	}
	if m.mid.IsZero() {
		err = errors.New("msgID must be set to delete the message")
		return
	}

	r := m.client.newRESTRequest(&httd.Request{
		Method:   httd.MethodDelete,
		Endpoint: endpoint.ChannelMessage(m.cid, m.mid),
		Ctx:      ctx,
	}, flags)
	r.expectsStatusCode = http.StatusNoContent

	_, err = r.Execute()
	return err
}

// Pin a message by its ID and channel ID. Requires the 'MANAGE_MESSAGES' permission.
// Returns a 204 empty response on success.
//  Method                  PUT
//  Endpoint                /channels/{channel.id}/pins/{message.id}
//  Discord documentation   https://discord.com/developers/docs/resources/channel#add-pinned-channel-message
//  Reviewed                2018-06-10
//  Comment                 -
func (m messageQueryBuilder) Pin(ctx context.Context, flags ...Flag) (err error) {
	r := m.client.newRESTRequest(&httd.Request{
		Method:   httd.MethodPut,
		Endpoint: endpoint.ChannelPin(m.cid, m.mid),
		Ctx:      ctx,
	}, flags)
	r.expectsStatusCode = http.StatusNoContent

	_, err = r.Execute()
	return err
}

// UnpinMessageID [REST] Delete a pinned message in a channel. Requires the 'MANAGE_MESSAGES' permission.
// Returns a 204 empty response on success. Returns a 204 empty response on success.
//  Method                  DELETE
//  Endpoint                /channels/{channel.id}/pins/{message.id}
//  Discord documentation   https://discord.com/developers/docs/resources/channel#delete-pinned-channel-message
//  Reviewed                2018-06-10
//  Comment                 -
func (m messageQueryBuilder) Unpin(ctx context.Context, flags ...Flag) (err error) {
	if m.cid.IsZero() {
		return errors.New("channelID must be set to target the correct channel")
	}
	if m.mid.IsZero() {
		return errors.New("messageID must be set to target the specific channel message")
	}

	r := m.client.newRESTRequest(&httd.Request{
		Method:   httd.MethodDelete,
		Endpoint: endpoint.ChannelPin(m.cid, m.mid),
		Ctx:      ctx,
	}, flags)
	r.expectsStatusCode = http.StatusNoContent

	_, err = r.Execute()
	return err
}

// DeleteAllReactions [REST] Deletes all reactions on a message. This endpoint requires the 'MANAGE_MESSAGES'
// permission to be present on the current user.
//  Method                  DELETE
//  Endpoint                /channels/{channel.id}/messages/{message.id}/reactions
//  Discord documentation   https://discord.com/developers/docs/resources/channel#delete-all-reactions
//  Reviewed                2019-01-28
func (m messageQueryBuilder) DeleteAllReactions(flags ...Flag) error {
	if m.cid.IsZero() {
		return errors.New("channelID must be set to target the correct channel")
	}
	if m.mid.IsZero() {
		return errors.New("messageID must be set to target the specific channel message")
	}

	r := m.client.newRESTRequest(&httd.Request{
		Method:   httd.MethodDelete,
		Endpoint: endpoint.ChannelMessageReactions(m.cid, m.mid),
		Ctx:      m.ctx,
	}, flags)
	r.expectsStatusCode = http.StatusNoContent

	_, err := r.Execute()
	return err
}

//////////////////////////////////////////////////////
//
// REST Wrappers
//
//////////////////////////////////////////////////////

func (m messageQueryBuilder) SetContent(ctx context.Context, content string) (*Message, error) {
	return m.Update(ctx).SetContent(content).Execute()
}

func (m messageQueryBuilder) SetEmbed(ctx context.Context, embed *Embed) (*Message, error) {
	return m.Update(ctx).SetEmbed(embed).Execute()
}

//////////////////////////////////////////////////////
//
// REST Builders
//
//////////////////////////////////////////////////////

// updateMessageBuilder, params here
//  https://discord.com/developers/docs/resources/channel#edit-message-json-params
//generate-rest-params: content:string, embed:*Embed,
//generate-rest-basic-execute: message:*Message,
type updateMessageBuilder struct {
	r RESTBuilder
}

// SetAllowedMentions sets the allowed mentions for the updateMessageBuilder then returns the builder to allow chaining.
func (b *updateMessageBuilder) SetAllowedMentions(mentions *AllowedMentions) *updateMessageBuilder {
	b.r.param("allowed_mentions", mentions)
	return b
}
