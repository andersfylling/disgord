package disgordutil

import (
	"fmt"
	"sort"
	"strings"
    "github.com/andersfylling/disgord"
    "reflect"
)

func Sort(v interface{}, sortByField SortFieldType, sortOrder SortOrderType) {
    if v == nil {
        return
    }

    {{- range $sorter := $.Sorters }}
    if sortByField == SortBy{{ $sorter.Field }} {
        sortBy{{ $sorter.Field }}(v, sortOrder)
    } else {{- end }} if list, ok := v.(sort.Interface); ok {
		if sortOrder == OrderDescending {
			sort.Sort(sort.Reverse(list))
		} else {
			sort.Sort(list)
		}
    } else {
        panic("type is missing sort.Interface implementation")
    }
}

func derefSliceP(v interface{}) (s interface{}) {
    switch t := v.(type) {
    {{- range $t := $.Types }}
    case *[]*disgord.{{ $t.Name }}:
        s = *t
    {{- end }}
    default:
        s = t
    }

    return s
}


{{- range $sorter := $.Sorters }}
func sortBy{{ $sorter.Field }}(v interface{}, sortOrder SortOrderType) {
    v = derefSliceP(v)
    if !reflectIsSlice(v) {
        return
    }

    var less func(i, j int) bool
    switch s := v.(type) {
    {{- range $t := $sorter.Types }}
    case []*disgord.{{ $t.Name }}:
        if sortOrder == OrderDescending {
            less = func(i, j int) bool { return {{ Descending $sorter.Field "s" }} }
        } else {
            less = func(i, j int) bool { return {{ Ascending $sorter.Field "s" }} }
        }
    {{- end }}
    default:
        panic(fmt.Sprintf("type %+v does not support sorting", s))
    }

    sort.Slice(v, less)
}
{{- end }}

func reflectIsSlice(v interface{}) bool {
    ValueIface := reflect.ValueOf(v)
    kind := ValueIface.Type().Kind()
    return kind == reflect.Slice
}
